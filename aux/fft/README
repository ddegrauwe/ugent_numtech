FFT library
===========

This is an interface library to the IFS/ALADIN FFT routines, to make their use somewhat easier. The convention relating the gridpoint array z to the spectral array zs is the following:

	z(ix) = sum_{kx=-nx/2}^{nx/2} zs(kx)*exp(i*kx*(ix-1)*2*pi/real(nx))



1. Compilation of the library
-----------------------------

Compile by typing

	make

in the directory containing the file Makefile.


2. Use
------

Two routines are of interest: FFT for the Fourier transform (gridpoint to spectral) and IFFT for the inverse Fourier transform (spectral to gridpoint).

To perform an FFT, use

  CALL FFT(Z,ZS)

where Z(1:NX) is a 1D real array with the gridpoint values. The spectral coefficients are stored in the complex 1D array ZS with dimensions (-NX/2:NX/2).

The inverse FFT is done with

  CALL IFFT(ZS,Z)

with the same conventions.

Similar routines exist for 2D Fourier transforms: FFT2 and IFFT2. This time, Z is a 2D array with dimensions (NX,NY), and ZS is a complex 2D array with dimensions (-NX/2:NX/2,-NY/2:NY/2).


3. Compilation of your program
------------------------------

Include the library by adding "-I {FFTDIR}/include/" and "-L{FFTDIR}/lib -lfft" to the gfortran call, where {FFTDIR} is the directory containing the FFT routines (e.g. /users/d/ddgrauwe/numtech/fft/):

	gfortran -O2 -fdefault-real-8 -I/users/d/ddgrauwe/numtech/fft/include/ myprog.F90 -o myprog \
	  -L/users/d/ddgrauwe/numtech/fft/lib -lfft

Make sure to include the -fdefault-real-8 switch!


4. Background
-------------

The convention of ordering the spectral coefficients in ALADIN/IFS is: 

	c0c0	c0s0	c0c1	c0s1	c0c2	c0s2
	s0c0	s0s0	s0c1	s0s1	s0c2	s0s2	
	c1c0	c1s0	c1c1	c1s1	c1c2	c1s2
	s1c0	s1s0	s1c1	s1s1	c1c2	s1s2
	c2c0	c2s0
	s2c0	s2s0				...

where c stands for "cosine" and s stands for "sine"; the numbers are the wavenumbers (0:n/2)

The convention used in this library is
	
	(-n/2,-n/2)			(-n/2,-n/2+1) 		(-n/2,-n/2+2)
	(-n/2+1,-n/2)		(-n/2+1,-n/2+1)		
	(-n/2+2,-n/2)											...

The conversion between both conventions goes as follows: let a wave be specified as
	Z = A_cc*cos(kx*x)*cos(ky*y) + A_sc*sin(kx*x)*cos(ky*y) + A_cs*cos(kx*x)*sin(ky*y) + A_ss*sin(kx*x)*sin(ky*y)

or as
	Z = A_++ * exp[i*(kx*x+ky*y)] + A_-+ * exp[i*(-kx*x+ky*y)] +  A_+- * exp[i*(kx*x-ky*y)] + A_-- * exp[i*(-kx*x-ky*y)]

where, if Z is to be real, A_++=conj(A_--) and A_+-=conj(A_-+).

The relation between A_cc,... and A_++ then is:

	A_++ = 1/4*(A_cc-A_ss) + i/4*(-A_sc-A_cs)
	A_-+ = 1/4*(A_cc+A_ss) + i/4*(A_sc-A_cs)
	A_+- = 1/4*(A_cc+A_ss) + i/4*(-A_sc+A_cs)
	A_-- = 1/4*(A_cc-A_ss) + i/4*(A_sc+A_cs)

or, vice versa:

	A_cc = A_++ + A_-+ + A_+- + A_--			= 2*RE{ A_++ + A_+- }
	A_sc = i*(A_++ - A_-+ + A_+- - A_--)  = 2*IM{ -A_++ + A_-+ }
	A_cs = i*(A_++ + A_-+ - A_+- - A_--)  = 2*IM{ -A_++ - A_-+ }
	A_ss = -A_++ + A_-+ + A_+- - A_--     = 2*RE{ -A_++ + A_-+ }

For some reason, the factors 4 shouldn't be there, and the factors 2 should be 0.5
