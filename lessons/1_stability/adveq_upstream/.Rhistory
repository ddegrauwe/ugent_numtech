plot(1:10)
ls(1)
ls()
ls(2)
q()
q()
library('Rgif')
plot(1:10)
library('Rpng')
library('png')
ls(1)
ls(2)
?writePNG
library('animation')
saveGIF
?saveGIF
saveGIF({
for (i in 1:10) plot(runif(10), ylim = 0:1)
})
saveSWF({
for (i in 1:10) plot(runif(10), ylim = 0:1)
})
?smooth.spline
x=1:10
y=runif(10)
plot(x,y)
plot(x,y,type='b')
S=smooth.spline(x,y)
xx=seq(1,10,len=91)
yy=predict(S,xx)
yy
points(xx,yy$y,col=2,type='l')
attach(cars)
plot(speed, dist, main = "data(cars)  &  smoothing splines")
cars.spl <- smooth.spline(speed, dist)
(cars.spl)
## This example has duplicate points, so avoid cv = TRUE
lines(cars.spl, col = "blue")
lines(smooth.spline(speed, dist, df = 10), lty = 2, col = "red")
legend(5,120,c(paste("default [C.V.] => df =",round(cars.spl$df,1)),
"s( * , df = 10)"), col = c("blue","red"), lty = 1:2,
bg = 'bisque')
detach()
y18 <- c(1:3, 5, 4, 7:3, 2*(2:5), rep(10, 4))
xx  <- seq(1, length(y18), len = 201)
(s2  <- smooth.spline(y18)) # GCV
(s02  <- smooth.spline(y18, spar = 0.2))
(s02. <- smooth.spline(y18, spar = 0.2, cv = NA))
plot(y18, main = deparse(s2$call), col.main = 2)
lines(s2, col = "gray"); lines(predict(s2, xx), col = 2)
lines(predict(s02, xx), col = 3); mtext(deparse(s02$call), col = 3)
## The following shows the problematic behavior of 'spar' searching:
(s2  <- smooth.spline(y18, control =
list(trace = TRUE, tol = 1e-6, low = -1.5)))
(s2m <- smooth.spline(y18, cv = TRUE, control =
list(trace = TRUE, tol = 1e-6, low = -1.5)))
y18 <- c(1:3, 5, 4, 7:3, 2*(2:5), rep(10, 4))
xx  <- seq(1, length(y18), len = 201)
(s2  <- smooth.spline(y18)) # GCV
(s02  <- smooth.spline(y18, spar = 0.2))
(s02. <- smooth.spline(y18, spar = 0.2, cv = NA))
plot(y18, main = deparse(s2$call), col.main = 2)
lines(s2, col = "gray"); lines(predict(s2, xx), col = 2)
lines(predict(s02, xx), col = 3); mtext(deparse(s02$call), col = 3)
xx
yy
x
y
s2=smooth.spline(y)
predict(s2,xx)
yy=y18 <- c(1:3, 5, 4, 7:3, 2*(2:5), rep(10, 4))
xx  <- seq(1, length(y18), len = 201)
(s2  <- smooth.spline(y18)) # GCV
(s02  <- smooth.spline(y18, spar = 0.2))
(s02. <- smooth.spline(y18, spar = 0.2, cv = NA))
plot(y18, main = deparse(s2$call), col.main = 2)
lines(s2, col = "gray"); lines(predict(s2, xx), col = 2)
lines(predict(s02, xx), col = 3); mtext(deparse(s02$call), col = 3)
y=c(1:3, 5, 4, 7:3, 2*(2:5), rep(10, 4))
''
''
''''
123
?splinefun
library('animation')
q()
loadResults()
loadResults
?loadResults
c=0.5; dt=1; dx=1; k=seq(0,pi/dx,len=101);
i
I
j
0+1i
1i
1i**2
omega=-1/(1i*dt)*log(1+dt*c*(exp(1i*k*dx)-1)/dx)
plot(k,real(omega))
plot(k,Re(omega))
plot(k,Im(omega))
plot(k,exp(Im(omega))
)
plot(k,-Re(omega))
c=1.1; dt=1; dx=1; k=seq(0,pi/dx,len=101);
omega=-1/(1i*dt)*log(1+dt*c*(exp(1i*k*dx)-1)/dx)
plot(k,exp(Im(omega)))
plot(k,Re(omega))
omega=-1/(1i*dt)*log(1+dt*c*(exp(-1i*k*dx)-1)/dx)
plot(k,Re(omega))
plot(k,Re(omega)); points(k,c*k)
omega=asin(c*dt/dx*sin(k*dx))
c=0.9; dt=1; dx=1; k=seq(0,pi/dx,len=101);
omega=asin(c*dt/dx*sin(k*dx))
plot(k,omega)
c=0.5;dt=1;dx=1;k=seq(0,pi/dx,len=101)
w=-1/(1i*dt)*log(1+c*dt/dx*(exp(1i*k*dx)-1))
w
plot(k,Re(w))
w=-1/(1i*dt)*log(1+c*dt/dx*(exp(-1i*k*dx)-1))
plot(k,Re(w))
plot(k,Re(w),type='l')
points(k,c*k)
c=0.9;dt=1;dx=1;k=seq(0,pi/dx,len=101)
w=-1/(1i*dt)*log(1+c*dt/dx*(exp(-1i*k*dx)-1))
plot(k,Re(w),type='l')
points(k,c*k)
plot(k,Im(w),type='l')
c=1.5;dt=1;dx=1;k=seq(0,pi/dx,len=101)
w=-1/(1i*dt)*log(1+c*dt/dx*(exp(-1i*k*dx)-1))
plot(k,Im(w),type='l')
q()
kk=seq(0,pi,len=101)
kk
A=(-1+sqrt(1-3*))/2
i
ii
I
i=1+0i
i
1i
A=(-1+sqrt(1-3/4*(1i*kk)*(3*1i*kk-4)))/2
A
plot(kk,exp(1i*kk))
plot(kk,abs(exp(1i*kk)))
plot(kk,abs(A)
)
A2=(-1-sqrt(1-3/4*(1i*kk)*(3*1i*kk-4)))/2
plot(kk,abs(A2))
q()
q()
By Philippe Grosjean November 29, 2015 Tweet Like +1
The primary goal of the tcltk R package is to use the Tk graphical user interface (GUI) toolkit with R. Here is a Tk window with an OK button that just destroys the window when it is clicked:
# Import the tcltk package
library(tcltk)
# Create a new Tk toplevel window assigned to win1
win1 <- tktoplevel()
# Create a Tk button whose function (command) is to destroy the window win1
butOK <- tkbutton(win1, text = "OK",
command = function() tkdestroy(win1))
# Place the button on the window, using the grid geometry manager
tkgrid(butOK)
library(tcltk)
# Create a new Tk toplevel window assigned to win1
win1 <- tktoplevel()
# Create a Tk button whose function (command) is to destroy the window win1
butOK <- tkbutton(win1, text = "OK",
command = function() tkdestroy(win1))
# Place the button on the window, using the grid geometry manager
tkgrid(butOK)
library(tcltk)
# Create a new Tk toplevel window assigned to win1
win1 <- tktoplevel()
# Create a Tk button whose function (command) is to destroy the window win1
butOK <- tkbutton(win1, text = "OK",
command = function() tkdestroy(win1))
# Place the button on the window, using the grid geometry manager
tkgrid(butOK)
dev.copy2pdf('asdf.pdf',width=4,height=4)
library(tkrplot)
q()
tt=tktoplevel()
source('H:/test/Rtcltk/test_tcltk.R')
source('H:/test/Rtcltk/test_tcltk.R')
# Global variables can go here
n <- 200
# Define the UI
ui <- bootstrapPage(
numericInput('n', 'Number of obs', n),
plotOutput('plot')
)
# Define the server code
server <- function(input, output) {
output$plot <- renderPlot({
hist(runif(input$n))
})
}
# Return a Shiny app object
shinyApp(ui = ui, server = server)
library(shiny)
bootstrapLib()
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
# Create Shiny app ----
shinyApp(ui = ui, server = server)
png(filename ='tmp.png',width=6,height=4);plot(1:100);dev.off()
png(filename ='tmp.png',width=600,height=400);plot(1:100);dev.off()
dev.off()
dev.off()
png(filename ='tmp.png',width=600,height=400);plot(1:100);dev.off()
png(filename ='tmp.png',width=600,height=400);plot(1:100);dev.off()
for (ii in 1:10) {png(filename ='tmp.png',width=600,height=400);plot(1:100);dev.off()}
ii
for (ii in 1:10) {png(filename ='tmp.png',width=600,height=400);plot(1:ii);dev.off()}
for (ii in 1:50) {png(filename ='tmp.png',width=600,height=400);plot(1:ii);dev.off()}
library(googleVis)
demo(googlevis)
demo(googleVis)
df=data.frame(country=c("US", "GB", "BR"),
val1=c(10,13,14),
val2=c(23,12,32))
Line <- gvisLineChart(df)
plot(Line)
x11();plot(Line)
library(googleVis)
df=data.frame(country=c("US", "GB", "BR"),
val1=c(10,13,14),
val2=c(23,12,32))
Line <- gvisLineChart(df)
plot(Line)
x11();plot(Line)
x11();plot(Line)
tempdir()
system('firefox')
system('iexplort')
system('iexplore')
system('iexplore',intern=FALSE)
zz=system('iexplore',intern=TRUE)
zz
plot.gvis("C:\\Users\\ddgrauwe\\AppData\\Local\\Temp\\12\\Rtmp023X2Y\\Chart_LineChartID2b3c47791aa5.html)
")"
""
plot.gvis("C:\\Users\\ddgrauwe\\AppData\\Local\\Temp\\12\\Rtmp023X2Y\\Chart_LineChartID2b3c47791aa5.html")
?plotwidgets
plot(Line)
wgPlanets(x = 0.5, y = 0.5, w = 1, h = 1, v, col = NULL,
border = NA, new = FALSE, res = 100, aspect = 1, adj = 0,
labels = NULL, label.params = NULL)
listPlotWidgets()
library(plotwidgets)
listPlotWidgets()
wgPlanets(x = 0.5, y = 0.5, w = 1, h = 1, v, col = NULL,
border = NA, new = FALSE, res = 100, aspect = 1, adj = 0,
labels = NULL, label.params = NULL)
v=runif(10)
wgPlanets(x = 0.5, y = 0.5, w = 1, h = 1, v, col = NULL,
border = NA, new = FALSE, res = 100, aspect = 1, adj = 0,
labels = NULL, label.params = NULL)
plot.new()
wgPlanets(x = 0.5, y = 0.5, w = 1, h = 1, v, col = NULL,
border = NA, new = FALSE, res = 100, aspect = 1, adj = 0,
labels = NULL, label.params = NULL)
v=runif(20)
wgPlanets(x = 0.5, y = 0.5, w = 1, h = 1, v, col = NULL,
border = NA, new = FALSE, res = 100, aspect = 1, adj = 0,
labels = NULL, label.params = NULL)
dev.off()
demo(googleVis)
plot(M)
plot(M)
system('c:/progra~2/google/chrome/application/chrome.exe')
M
class(M)
plot.gvis
plot.default
plotGoogleMaps::plotGoogleMaps()
print(M)
zz=print(M)
tempdir()
tempdir()
system(sprintf('ls %s',tempdir()))
system(sprintf('%s %s','c:/progra~2/google/chrome/application/chrome.exe','MotionChartID2b3c728b3cfa.html')
)
system(sprintf('%s %s/%s','c:/progra~2/google/chrome/application/chrome.exe',tempdir(),'MotionChartID2b3c728b3cfa.html'))
system('firefox.exe')
plot(M)
system(sprintf('%s %s/%s','firefox.exe',tempdir(),'MotionChartID2b3c728b3cfa.html'))
system(sprintf('%s %s/%s','c:/progra~2/mozill~1/firefox.exe',tempdir(),'MotionChartID2b3c728b3cfa.html'))
system(sprintf('%s file:///%s/%s','c:/progra~2/mozill~1/firefox.exe',tempdir(),'MotionChartID2b3c728b3cfa.html'))
system(sprintf('ls %s',tempdir()))
system(sprintf('%s file:///%s/%s','c:/progra~2/mozill~1/firefox.exe',tempdir(),'LineChartID2b3c59155c38.html'))
system(sprintf('%s %s/%s','c:/progra~2/google/chrome/application/chrome.exe',tempdir(),'TableID2b3c5244518c.html'))
q()
library(rgl)
saveopts <- options(rgl.useNULL = TRUE)
objid <- plot3d(1:10, 1:10, rnorm(10), col=c("red", "red"), type = "s")["data"]
control <- ageControl(value=0,
births=1:10,
ages = c(-5,0,5),
colors = c("green", "yellow", "red"),
objids = objid)
# This example uses explicit names
rglwidget(elementId = "theplot", controllers = "theplayer",
height = 300, width = 300)
playwidget("theplot", control, start = -5, stop = 5,
rate = 3, elementId = "theplayer",
components = c("Play", "Slider"))
# This example uses pipes, and can skip the names
widget <- rglwidget(height = 300, width = 300) %>%
playwidget(control, start = -5, stop = 5,
rate = 3, components = c("Play", "Slider"))
if (interactive())
widget
options(saveopts)
library(Rfa)
library("rgl", lib.loc="C:/Program Files/R/R-3.3.2/library")
detach("package:rgl", unload=TRUE)
library("animation", lib.loc="C:/Program Files/R/R-3.3.2/library")
example(animation)
setwd("H:/numtech/2017-2018/lessons/nt1/adveq_upstream")
source('show.R')
animateResults()
animateResults()
animateResults()
animateResults()
animateResults()
q()
